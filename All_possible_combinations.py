from itertools import permutations
from fpdf import FPDF
import time

def addition_algorithm(a, b, c, result):
    # Convert numbers to strings
    a_str = str(a)
    b_str = str(b)
    c_str = str(c)
    result_str = str(result)
    
    # Calculate the maximum length for proper alignment
    max_length = max(len(a_str), len(b_str), len(c_str), len(result_str))

    # Pad numbers with leading spaces for alignment
    a_str = a_str.rjust(max_length)
    b_str = b_str.rjust(max_length)
    c_str = c_str.rjust(max_length)
    result_str = result_str.rjust(max_length)

    # Create the ASCII art for the addition
    return f"   {a_str}\n+  {b_str}\n+  {c_str}\n{'-' * (max_length + 5)}\n   {result_str}\n{'-' * (max_length + 5)}"

def find_valid_combinations():
    digits = '0123456789'
    valid_solutions = []
    
    for perm in permutations(digits):
        if '0' not in perm:  # Ensure '0' is included in the sum
            continue

        one_digit = int(perm[0])
        two_digit = int(''.join(perm[1:3]))
        three_digit = int(''.join(perm[3:6]))
        result = int(''.join(perm[6:10]))

        if one_digit + two_digit + three_digit == result and 1000 <= result <= 9999:
            valid_solutions.append((one_digit, two_digit, three_digit, result))
    
    return valid_solutions

def export_to_pdf(solutions):
    # Create PDF
    pdf = FPDF()
    pdf.add_page()

    # Title
    pdf.set_font("Arial", "B", 16)
    pdf.set_text_color(0, 0, 255)  # Blue color for the title
    pdf.cell(200, 10, txt="Valid Addition Solutions", ln=True, align='C')
    pdf.ln(10)  # Line break

    # Set the font for the solutions
    pdf.set_font("Courier", size=12)
    pdf.set_text_color(0, 0, 0)  # Black color for the text

    for sol in solutions:
        # ASCII art for each solution
        addition_str = addition_algorithm(sol[0], sol[1], sol[2], sol[3])
        
        # Add the formatted addition to the PDF
        pdf.multi_cell(0, 10, addition_str)
        pdf.ln(5)  # Add a little space after each solution

    # Footer
    pdf.set_font("Arial", "I", 10)
    pdf.set_y(-15)
    pdf.cell(0, 10, "Generated by Your Algorithm Finder", 0, 0, "C")

    # Save the PDF
    pdf.output("addition_solutions_pretty.pdf")
    print("PDF exported as addition_solutions_pretty.pdf")

def print_solutions(solutions, show_ascii=True):
    if solutions:
        for sol in solutions:
            if show_ascii:
                print(addition_algorithm(sol[0], sol[1], sol[2], sol[3]))
            else:
                print(f"{sol[0]} + {sol[1]} + {sol[2]} = {sol[3]}")
        print(f"\nTotal valid combinations found: {len(solutions)}")
    else:
        print("No valid combinations found.")

def main():
    solutions = find_valid_combinations()

    # Get user input for how to display the solutions
    choice = input("Enter 'a' for ASCII art (Algorithm shaped), 'n' for normal printing, 'b' for both, or 'p' to export to PDF or 'ap' for ASCII and PDF or 'np' for normal printing and PDF: ").lower()

    if choice == 'a':
        print_solutions(solutions, show_ascii=True)
    elif choice == 'n':
        print_solutions(solutions, show_ascii=False)
    elif choice == 'b':
        print_solutions(solutions, show_ascii=True)
        print_solutions(solutions, show_ascii=False)
    elif choice == 'p':
        export_to_pdf(solutions)
    elif choice == 'ap':
        print_solutions(solutions, show_ascii=True)
        export_to_pdf(solutions)
    elif choice == 'np':
        print_solutions(solutions, show_ascii=False)
        export_to_pdf(solutions)
    else:
        print("Invalid choice. Please enter a valid option.")
        main()  # Call main again to let the user try again

if __name__ == "__main__":
    main()  # Start the program
time.sleep(1800)